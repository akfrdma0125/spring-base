# spring-base

## 테스트 필요성
Legacy 코드란 뭘까? 시간과 상관없이 테스트가 없는 코드

테스트의 목적
1. regression 버그 방지: 잘 돌아가던 코드가 이번 배포에는 안 돼요 ㅠㅠ 방지
2. 좋은 아키텍처를 유도
-> 좋은 테스트를 하다보면, SOLID 원칙을 지키게 됨

## 테스트 3분류
**LARGE** (5%): 멀티 서버<br>
**MEDIUM** (15%): 단일 서버, 멀티 프로세스, 멀티 스레드<br>
  H2를 이용하는 순간, MEDIUM 테스트 레벨이 되기 때문에 지양해야 함<br>
**SMALL (80%): 단일 서버, 단일 프로세스 및 스레드, blocking call 없음**

SMALL 수준의 테스트 코드를 작성하는 게 중요함!!



## 테스트 개념
- SUT: System under test (테스트 하려는 대상)
- BDD: Behaviour driven development (**given-when-then**), 유저가 시스템을 사용하는 user story를 강조하고 시나리오를 강조함
- 상태 검증: 결과 자체만 보고 비교
- 행위 검증: 테스트에 넣었을 때, 협력 객체의 어떤 메서드를 실행하는가?
- 테스트 픽스처: 테스트에 필요한 자원을 생성하는 것 (가급적 지양)
  ex. User 객체를 미리 할당 @BeforeEach
- 비욘세 규칙: 유지하고 싶은 상태가 있으면 전부 테스트로 작성 -> 그게 곧 정책이 됨
  ex. 유저 아이디는 이메일이라는 정책 -> 이메일이 아니라면, 예외를 던지는 테스트를 작성
- Test double: 테스트 대역
  ex. 회원가입에 이메일 발송이 필요 -> 이메일을 발송하는 대역

## 대역
- **dummy**: 아무런 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
- **fake**: Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체, 자체적인 로직이 있다는 게 특징
- **stub**: 미리 준비된 값을 출력하는 객체, mockito 프레임워크를 이용
- **mock**: 메서드 호출을 확인하기 위한 객체
- **spy**: 메서드 호출을 전부 기록했다가 나중에 확인하기 위한 객체

## 의존성
다른 객체의 함수를 사용하는 상태<br>
🙃 a는 b를 사용하기만 해도 a는 b에 의존한다고 볼 수 있다.


### 의존성 주입
원래는 객체를 만들어서 호출하던 걸, 객체 자체를 넣음으로써, 의존성을 약하게 만드는 대표적인 테크닉 중 하나<br><br>
**근데, 의존성 주입이 의존성을 완전히 없애는 건 아님**
<br>
왜냐면 어쨌거나 해당 객체를 **사용**하고 있다는 건 변하지 않음
<br>
결론은, 의존성을 없애는 게 아니라 의존성을 약화 시키기 위해 노력한다고 보는 게 맞음
<br><br>
**그럼 왜 의존성 주입을 할까?**

new는 사실상 하드 코딩이기 때문에!<br>

가령 햄버거를 만들 때 Meat라는 객체를 인스턴스화 하면 이제 햄버거 만들려면 Meat 없이는 불가능함<br>

근데, 외부에서 받으면 (상속 등을 이용해서) 소고기/ 돼지고기로 받을 수 있음<br>

### 의존성 역전(DIP)
**의존성 역전 != 의존성 주입**
<br>
- 기존 코드: <br>
셰프 -> 비프 : 셰프는 비프를 사용한다
- 의존성 역전: <br>
셰프 -> 미트<<인터페이스>> <- 소고기

<br>

**인터페이스와 구현을 분리하는 경우 -> 이걸 의존성 역전했다고 부름**

<br>

**근데 왜 의존성 주입이냐?**
<br>
소고기 입장에서 원래는 화살표가 들어오는 입장이었는데, 화살표가 나가는 방향으로 바뀜, 의존성의 방향이 바뀜
<br>
- 상위 모듈(셰프)와 하위 모듈(비프) 모두 추상화(미트)에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안 된다. 비프 (세부사항)이 미트(추상화)에 의존하고 있음

### 테스트와 의존성
**테스트에서 의존성은 숨겨져 있으면 안 됨!!**
<br>
<br>
그럼 어떻게 수정해야 하냐면<br>
의존성을 외부에서 주입하게 해야 함 ➡️ 의존성 주입<br>
근데 이런 식으로 가면 어딘가는 고정값을 주어야 할 수도 있음 <br>
-> 테스트하기 힘들어짐<br><br>

**의존성 역전 도입**
<br>ex. <br>
clockholder <<interface>> 을 만들고
- systemclockholder
- testclockholder

➡️ 이렇게 배포 환경과 테스트 환경을 분리

## 테스트 가능성
얼마나 쉽게 input을 변경할 수 있고, output을 얼마나 쉽게 검증할 수 있는가

- 숨겨진 의존성
- 하드코딩된 외부 시스템과 연동되어있는경우
- 콘솔에 출력하는 게 전부일 때

## 테스트 코드
**커버리지 측정 <br>**

![img.png](img.png)

테스트 패키지 우클릭 > 그 외 실행/디버그 > 커버리지로 실행 클릭


# TEST CODE

---
## FIRST 원칙
- Fast: 빠르게
- Independent: 독립적으로
- Repeatable: 반복 가능하게
- Self-validating: 스스로 검증 가능하게
- Timely: 적시에 _**(코드 구현 전)**_

---

## 의존성
다른 객체의 함수를 사용하는 상태<br>
🙃 a는 b를 사용하기만 해도 a는 b에 의존한다고 볼 수 있다.

### 의존성 주입
외부에서 객체 자체를 주입함으로써, 의존성을 약하게 만드는 대표적인 테크닉 중 하나<br>
_(원래는 객체를 만들어서 호출했음 (new 함수))_ <br><br>
**근데, 의존성 주입이 의존성을 완전히 없애는 건 아님**
<br>
왜냐면, 해당 객체를 **사용**하고 있다는 건 변하지 않음
<br>
#### **그럼 왜 의존성 주입을 할까?**

new는 사실상 하드 코딩이기 때문에!<br>

햄버거를 만들 때 소고기 객체를 인스턴스화(new)하면 이제 햄버거 만들려면 Meat 없이는 불가능함<br>
그러나, 의존성 주입으로 고기라는 인터페이스를 만들고 받으면, 소고기/ 돼지고기/... 로 받을 수 있음<br>
_이건 약간 의존성 주입 개념이 들어가긴 함.._<br>
_그렇지만, 원하는 정보를 상황에 따라서 선택해서 넣을 수 있음 (굳이 의존성 역전을 하지 않아도)_


결론은, 의존성 주입은 의존성을 없애는 게 아니라 **의존성을 약화**시키기 위해 노력한다고 보는 게 맞음<br>

### 의존성 역전(DIP)
**의존성 역전 != 의존성 주입**
<br>
- 기존 코드: <br>
  셰프 → 소고기 : 셰프는 소고기를 사용한다
- 의존성 역전: <br>
  셰프 → 미트 *<<인터페이스>>* ←소고기
  <br>→ 소고기는 의존을 받는 입장에서 미트라는 인터페이스를 의존하게 됨, 의존성 방향이역전됨

#### → 인터페이스와 구현을 분리하는 경우 → 이걸 의존성 역전했다고 부름

#### 원칙
- 상위 모듈(셰프)와 하위 모듈(소고기) 모두 추상화(미트)에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안 된다. 소고기(세부사항)이 미트(추상화)에 의존하고 있음

### 테스트와 의존성

테스트에서 의존성은 매우 중요한 개념임

**테스트에서 숨겨진 의존성이 있으면 안 됨**
<br>
→ 그럼 어떻게 수정해야 하냐면<br>
1. 의존성 주입
   <br> 그러나, 이런 식으로 가면 어딘가는 고정값을 주어야 할 수도 있음
   <br> 테스트하기 어려워짐 (좋은 코드가 아님)
2. 의존성 역전

   : 생성 시간을 넣는 코드<br>
   기존 코드: Clock이라는 외부 라이브러리에 의존하고 있음<br>
   **DI**: 테스트할 때, 외부에서 Clock 객체를 주입한다 <br>
   → 최상위 클래스를 테스트할 때는 결국 고정값을 주어야 하는 상황 발생<br>
   **DIP**: clockholder 인터페이스를 만들고, 이를 구현하는 클래스를 만들어서 사용<br>
   - systemclockholder (실제 비지니스 로직용)<br>
   - testclockholder (테스트용)

→ 이렇게 배포 환경과 테스트 환경을 분리하는 것이 좋음

---
## 테스트
### 테스트 목적
1. regression 버그 방지
<br>_잘 돌아가던 코드가 이번 배포에는 안 돼요 ㅠㅠ 방지_
2. 좋은 아키텍처를 유도
<br> 테스트를 하다보면, SOLID 원칙을 지키게 됨

### 테스트 3분류
**LARGE** (5%): 멀티 서버<br>
**MEDIUM** (15%): 단일 서버, 멀티 프로세스, 멀티 스레드<br>
H2를 이용하는 순간, MEDIUM 테스트 레벨이 되기 때문에 지양해야 함<br>
**SMALL (80%): 단일 서버, 단일 프로세스 및 스레드, blocking call 없음**

#### →_SMALL 수준의 테스트 코드를 작성하는 게 중요함!!_

### 테스트 개념
- SUT: System under test (테스트 하려는 대상)
- BDD: Behaviour driven development (**given-when-then**), 유저가 시스템을 사용하는 user story를 강조하고 시나리오를 강조함
- 상태 검증: 결과 자체만 보고 비교
- 행위 검증: 테스트에 넣었을 때, 협력 객체의 어떤 메서드를 실행하는가?
- 테스트 픽스처: 테스트에 필요한 자원을 생성하는 것 (가급적 지양)
<br> ex. User 객체를 미리 할당 @BeforeEach
- 비욘세 규칙: 유지하고 싶은 상태가 있으면 전부 테스트로 작성 
<br>→ 그게 곧 정책이 됨
<br>ex. 유저 아이디는 이메일이라는 정책 → 이메일이 아니라면, 예외를 던지는 테스트를 작성
- Test double: 테스트 **대역**
<br>ex. 회원가입에 이메일 발송이 필요 -> 이메일을 발송하는 대역

### 대역
- **dummy**: 아무런 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
- **fake**: Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체, 자체적인 로직이 있다는 게 특징
- **stub**: 미리 준비된 값을 출력하는 객체, 주로 mockito 프레임워크를 이용
- **mock**: 메서드 호출을 확인하기 위한 객체 (http)
- **spy**: 메서드 호출을 전부 기록했다가 나중에 확인하기 위한 객체

### 테스트 가능성
얼마나 쉽게 input을 변경할 수 있고, output을 얼마나 쉽게 검증할 수 있는가

#### 테스트 하기 어려운 경우
- 숨겨진 의존성
- 하드코딩된 외부 시스템과 연동되어 있는 경우
- 콘솔에 출력하는 경우 (System.out.println)

→ 결국 테스트하기 쉽게 하다보면, 헥사고날 or DDD 아키텍처를 갖게 됨

---
### 테스트 코드
**커버리지 측정 <br>**

![img.png](img.png)

테스트 패키지 우클릭 → 그 외 실행/디버그 → 커버리지로 실행 클릭 <br>
_커버리지는 테스트 지표 중 하나지만, 일정 수준의 커버리지를 달성했다고 해서 좋은 코드는 아님_

#### 테스트 코드 작성 팁
1. 동일 로직을 여러 input으로 테스트하고 싶을 때
 ```
 @ParameterizedTest
 @MethodSource("provideStringsForIsBlank")
 ```
2. assertAll
<br> 여러 assert를 한 번에 실행할 수 있음 (중간에 실패한다고 해도 모두 실행됨)
3. 테스트의 범위
<br> 테스트는 **최소한의 범위**로 작성하는 게 좋음 (하나의 기능)
<br> 근데, test by test이므로, 어떤 식으로 표현하냐가 핵심
4. Thread.sleep 지양
<br> 테스트 환경에 따라 결과가 달라질 수 있음



